package com.anuous.boot.algorithm.tree;

/**
 *      //左旋（逆时针）： 把自己变成右节点的左节点，原先右节点的左节点 变成自己的右节点
 *     //右旋（顺时针）：把自己变成左节点的右节点，原先左节点的右节点 变成自己的左节点
 *     //=====================================================================================
 *     //红黑树定义：
 *    //====================================================================================
 *     //新插入的节点 都为红色
 *     // 1、每个节点不是红色就是黑色
 *     //2、不可能有连在一起的红色节点（黑色的可以），每个叶子节点都是黑色的空节点（nil）,也就是说叶子节点不存储数据
 *     //3、根节点都是黑色
 *     //4、每个节点，从该节点到达其可以到达的叶子节点的所有路径，都包含相同数目的黑色节点。
 *     //=====================================================================================
 *      ###A、插入时候的 旋转和变色规则 #####
 *     //====================================================================================
 *     #变色规则：当前节点的父亲节点是红色的，并且其祖父节点的另一个子节点也是红色的（即叔叔节点为红色）
 *     a、把父亲节点设为黑色、叔叔节点设为黑色、把祖父节点设为红色
 *     b、把当前操作节点设为祖父节点
 *     #左旋：当前父节点是红色，叔叔节点是黑色的时候，且当前节点是右子树。左旋：以父节点作为左旋。指针变到父节点
 *     #右旋：当前父节点是红色，叔叔节点是黑色的时候，且当前节点是左子树，右旋：
 *            1、把父节点变成为黑色
 *            2、把祖父节点变成红色
 *            3、以祖父节点右旋
 *     //============================================================================
 */
public class BlackRedTree {

    private Integer data;

    private BlackRedTree leftNode;

    private BlackRedTree rightNode;

    private BlackRedTree parentNode;

    private int coler = 1;


}
